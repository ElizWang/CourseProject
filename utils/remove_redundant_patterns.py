import sys
sys.path.insert(1, 'utils/frequent_pattern_mining')

from build_frequent_patterns import FrequentPatternBuilder
from parse_patterns import parse_file_into_patterns

'''
Utility methods for 
* Calculating Jaccard distance
* Eliminating redundancy using one pass microclustering
'''

def calculate_jaccard_distance(pattern_1, pattern_2):
    '''
    Computes Jaccard distance based on this formula:
        1 - |intersection(pattern 1, pattern 2)| / |union(pattern 1, pattern 2)|

    @param pattern_1: list(int)     A pattern parsed from an output file generated by
        build_frequent_patterns.py
    @param pattern_2: list(int)     A pattern parsed from an output file generated by
        build_frequent_patterns.py
    @return a float representing the Jaccard distance between the two patterns
    '''
    pattern_1_set = set(pattern_1)
    pattern_2_set = set(pattern_2)
    intersection_len = len(pattern_1_set.intersection(pattern_2_set))
    union_len = len(pattern_1_set.union(pattern_2_set))
    return 1 - intersection_len / union_len

def find_one_pass_microclustering_patterns(patterns, dist_thresh = 0.9):
    '''
    Computes a list of non-redundant patterns using the one-pass microclustering
    algorithm

    @param patterns: list(list(int)):   A list of patterns, where each pattern is 
        a list(int)
    @param dist_thresh: float           Distance threshold, used when deciding whether
        to place a pattern in an existing cluster or create a new cluster for it
    '''
    # Patterns are denoted by their index
    # Jaccard dists are keyed via tuples -- (p1_ind, p2_ind) such that 
    # p1_ind < p2_ind
    jaccard_dists = {}
    num_patterns = len(patterns)
    for i in range(num_patterns):
        for j in range(i, num_patterns):
            jaccard_dists[ (i ,j) ] = calculate_jaccard_distance(patterns[i], patterns[j])

    def get_jaccard_dist(id_1, id_2):
        return jaccard_dists[ (min(id_1, id_2), max(id_1, id_2)) ]

    # Stores pattern IDs rather than pattern lists
    clusters = {}
    curr_cluster_id = 0

    for pattern_id in range(num_patterns):
        min_dist_cluster_id = float("inf")
        min_dist = float("inf")

        for cluster_num in clusters:
            cluster_pattern_ids = clusters[cluster_num]
            max_pattern_cluster_dist = max(get_jaccard_dist(pattern_id, cluster_pattern_id)\
                for cluster_pattern_id in cluster_pattern_ids)

            if min_dist > max_pattern_cluster_dist:
                min_dist = max_pattern_cluster_dist
                min_dist_cluster_id = cluster_num

        if min_dist < dist_thresh:
            clusters[min_dist_cluster_id].append(pattern_id)
        else:
            clusters[curr_cluster_id] = [pattern_id]
            curr_cluster_id += 1
    
    min_intra_dist_patterns = []

    for cluster_num in clusters:
        cluster_pattern_ids = clusters[cluster_num]
        min_intra_cluster_pattern_id = float("inf")
        min_avg_dist = float("inf")

        for pattern_id in cluster_pattern_ids:
            avg_intra_cluster_dist = sum(get_jaccard_dist(pattern_id, cluster_pattern_id)\
                for cluster_pattern_id in cluster_pattern_ids) / len(cluster_pattern_ids)

            if min_avg_dist > avg_intra_cluster_dist:
                min_avg_dist = avg_intra_cluster_dist
                min_intra_cluster_pattern_id = pattern_id

        min_intra_dist_patterns.append(patterns[min_intra_cluster_pattern_id])
    print(min_intra_dist_patterns)
    return min_intra_dist_patterns

if __name__ == "__main__":
    title_patterns = parse_file_into_patterns(FrequentPatternBuilder.TITLE_TERMS_OUTPUT_FILE_PATH)
    find_one_pass_microclustering_patterns(title_patterns)